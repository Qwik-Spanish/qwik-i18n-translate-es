---
title: Getting Started
contributors:
  - manucorporat
  - jesperp
  - adamdbradley
  - steve8708
  - cunzaizhuyi
  - mousaAM
  - zanettin
  - Craiqser
  - MyltsinVV
  - literalpie
  - colynyu
  - the-r3aper7
  - ahmadalfy
  - renomureza
  - mhevery
  - AnthonyPAlicea
  - kapunahelewong
  - kushalmahajan
  - sreeisalso
  - dustinsgoodman
---

import CodeSandbox from '../../../../components/code-sandbox/index.tsx';

# Comenzando r谩pidamente con Qwik
Qwik es un nuevo tipo de framework que es [reanudable](../concepts/resumable/index.mdx) (sin ejecuci贸n de JS precipitada y sin hidrataci贸n), construido para edge y [familiar para desarrolladores React](/docs/integrations/react/index.mdx).

Para empezar a usarlo de inmediato, echa un vistazo a nuestro playground en el navegador:

- [StackBlitz Qwik](https://qwik.new) (Qwik Completo + integracion con Qwikcity)
- [Playground de Ejemplos](/examples/reactivity/counter/) (Solo Qwik, sin enrutado)

## Pre-requisitos

Para comenzar con Qwik localmente, necesitas lo siguiente:

- [Node.js v16.8](https://nodejs.org/en/download/) o superior
- Tu IDE favorito ([vscode](https://code.visualstudio.com/) recomendado)
- Opcionalmente, lee [think qwik](../think-qwik/index.mdx)


## Crea una aplicaci贸n usando la CLI

Primero, crea una aplicaci贸n Qwik con la CLI de Qwik, que genera un inicio en blanco para que puedas familiarizarte r谩pidamente con 茅l.

Ejecuta la CLI de Qwik en tu terminal. Qwik admite NPM, yarn y pnpm. Elige el gestor de paquetes que prefieras y ejecuta uno de los siguientes comandos:

```shell
npm create qwik@latest
pnpm create qwik@latest
yarn create qwik@latest
```

El CLI te gu铆a a trav茅s de un men煤 interactivo para establecer el nombre del proyecto, seleccionar uno de los inicios y preguntar谩 si quieres instalar las dependencias. Obt茅n m谩s informaci贸n sobre los archivos generados consultando la documentaci贸n de [Estructura del Proyecto](/docs/project-structure/).

Inicia el servidor de desarrollo:

```shell
npm start
pnpm start
yarn start
```

## Qwik Chiste App

El tutorial de Qwik Hello World te gu铆a a trav茅s de la construcci贸n de una aplicaci贸n de chiste con Qwik mientras cubre los conceptos m谩s importantes de Qwik. La aplicaci贸n muestra un chiste aleatorio de https://icanhazdadjoke.com y cuenta con un bot贸n para obtener un nuevo chiste al hacer clic.

### 1. Crea una ruta

Comienza sirviendo una p谩gina en una ruta en particular. Esta aplicaci贸n b谩sica sirve una aplicaci贸n de chiste aleatorio en la ruta `/joke/`. Este tutorial se basa en Qwikcity, el meta-framework de Qwik, que utiliza [directory-based](/docs/(qwikcity)/routing/index.mdx) routing. Para comenzar:

1. En tu proyecto, crea un nuevo directorio `joke` en `routes` que contenga un archivo `index.tsx`.
2. Cada ruta `index.tsx` debe tener un `export default component$(...)` para que Qwikcity sepa qu茅 contenido servir. Pega el siguiente contenido en `src/routes/joke/index.tsx`:

<CodeSandbox src="/src/routes/demo/getting-started/01-route/index.tsx" style={{ height: '6em' }}>
```tsx {3-5} title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <section class="section bright">A Joke!</section>;
});
```
</CodeSandbox>

3. Navega a `http://127.0.0.1:5173/joke/` para ver tu nueva p谩gina funcionando.

> NOTA:
>
> - Tu componente de ruta `joke` predeterminado est谩 rodeado de un dise帽o existente. Consulta [Layout](/docs/layout/) para obtener m谩s detalles sobre qu茅 son los dise帽os y c贸mo trabajar con ellos.
> - Para mas detalles sobre como escribir componentes, consulta la secci贸n [Component API](/docs/(qwik)/components/overview/index.mdx).

### 2. Cargando Datos

Vamos a usar la API JSON externa en https://icanhazdadjoke.com para cargar chistes aleatorios. Usaremos [route loaders](/docs/(qwikcity)/route-loader/index.mdx) para cargar estos datos en el servidor y luego representarlos en el componente.

1. Abre `src/routes/joke/index.tsx` y agrega este c贸digo:

```tsx /routeLoader\$/ title="src/routes/joke/index.tsx"
<CodeSandbox src="/src/routes/demo/getting-started/02-loading-data/index.tsx" style={{ height: '6em' }}>
```tsx /routeLoader$/ /useDadJoke/#a title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export default component$(() => {
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
    </section>
  );
});
```
</CodeSandbox>

2. Now en `http://localhost:5173/joke/`, el navegador muestra un chiste aleatorio.
Explicaci贸n del c贸digo:

- La funci贸n pasada a `routeLoader$` se invoca en el servidor antes de que se renderice cualquier componente y es responsable de cargar los datos.
- El `routeLoader$` devuelve un use-hook, `useDadJoke()`, que se puede usar en el componente para recuperar los datos del servidor.

> **NOTA**
>
> - El `routeLoader$` es invocado precipitadamente en el servidor antes de que se renderice cualquier componente, incluso si su use-hook no se invoca en ning煤n componente.
> - El tipo de retorno de `routeLoader$` se infiere en el componente sin necesidad de informaci贸n de tipo adicional.


### 3. Enviando datos al servidor

Anteriormente, usamos `routeLoader$` para enviar datos del servidor al cliente. Para publicar (enviar) datos del cliente al servidor, usamos [`routeAction$`](/docs/(qwikcity)/action/index.mdx).

NOTA: `routeAction$` es la forma preferida de enviar datos al servidor porque utiliza la API de formulario nativa del navegador, que funciona incluso si JavaScript est谩 deshabilitado.
Para declarar una acci贸n, agrega este c贸digo:


```tsx /routeAction\$/ title="src/routes/joke/index.tsx"
import { routeAction$, Form } from '@builder.io/qwik-city';

export const useJokeVoteAction = routeAction$((props) => {
  // Leave it as an exercise for the reader to implement this.
  console.log('VOTE', props);
});
```

2. Actualiza el componente `export default` para usar el use-hook `useJokeVoteAction` con `<Form>`.

```tsx {3,7-11} /favoriteJokeAction/ title="src/routes/joke/index.tsx"
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up"></button>
        <button name="vote" value="down"></button>
      </Form>
    </section>
  );
});
```

3. Ahora en `http://localhost:5173/joke/`, los botones se muestran y si haces clic en ellos, su valor se registra en la consola.

Explicaci贸n del c贸digo:

- `routeAction$` recibe los datos.
  - La funci贸n pasada a `routeAction$` se invoca en el servidor cada vez que se publica el formulario.
  - El `routeAction$` devuelve un use-hook, `useJokeVoteAction`, que se puede usar en el componente para publicar los datos del formulario.
- `Form` es un componente de conveniencia que envuelve el elemento nativo `<form>` del navegador.


Cosas a tener en cuenta:

- Para la validaci贸n, consulte [zod validation](/docs/(qwikcity)/action/index.mdx#zod-validation).
- El `routeAction$` funciona incluso si JavaScript est谩 deshabilitado.
- Si JavaScript est谩 habilitado, el componente `Form` evitar谩 que el navegador publique el formulario y, en su lugar, publicar谩 los datos usando JavaScript y emular谩 el comportamiento nativo del formulario del navegador sin una actualizaci贸n completa.

Para referencia, el c贸digo completo de esta secci贸n es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/03-posting-data/index.tsx" style={{ height: '8em' }}>
```tsx {21,25-29} /favoriteJokeAction/ title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          
        </button>
        <button name="vote" value="down">
          
        </button>
      </Form>
    </section>
  );
});
```
</CodeSandbox>

### 4. Modificando el estado

El seguimiento del estado y la actualizaci贸n de la interfaz de usuario es fundamental para lo que hacen las aplicaciones. Qwik proporciona un gancho `useSignal` para realizar un seguimiento del estado de la aplicaci贸n. Para obtener m谩s informaci贸n, consulte [state management](/docs/components/state/).

Para declarar el estado:

1. Import `useSignal` from `qwik`.
   ```tsx /useSignal/
   import { component$, useSignal } from "@builder.io/qwik";
   ```
2. Declare the component's state using `useSignal()`.
   ```tsx /useSignal/
   const isFavoriteSignal = useSignal(false);
   ```
3. After the closing `Form` tag, add a button to the component to modify the state.
   ```tsx /isFavoriteSignal/
   <button
    onClick$={() => {
      isFavoriteSignal.value = !isFavoriteSignal.value;
    }}>
     {isFavoriteSignal.value ? 'わ' : ''}
   </button>
   ```

NOTA: Al hacer clic en el bot贸n se actualiza el estado, que a su vez actualiza la interfaz de usuario.

Para referencia, el c贸digo completo de esta secci贸n es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/04-state/index.tsx" style={{ height: '10em' }} maxHeight={500}>
```tsx /isFavoriteSignal/ title="src/routes/joke/index.tsx"
import { component$, useSignal } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();

  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          
        </button>
        <button name="vote" value="down">
          
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? 'わ' : ''}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 5. Tareas e Invocaci贸n de C贸digo del Servidor

En Qwik, una [tarea](/docs/components/tasks/#usetask) es un trabajo que debe realizarse cuando cambia un estado. (Esto es similar a un "efecto" en otros frameworks.) En este ejemplo, usamos la tarea para invocar c贸digo en el servidor.

1. Cree una nueva tarea que realice un seguimiento del estado de `isFavoriteSignal`:
   ```tsx /useTask\$/
   useTask$(({ track }) => {});
   ```
2. Agregue una llamada `track` para volver a ejecutar la tarea en el cambio de estado de `isFavoriteSignal`:
   ```tsx /track/
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
   });
   ```
3. Agregue el trabajo que desea ejecutar en el cambio de estado:
   ```tsx {3}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
   });
   ```
4. Si desea que el trabajo se realice solo en el servidor, envu茅lvalo en `server$()`
   ```tsx /server\$/ {4-6}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
     server$(() => {
       console.log('FAVORITE (server)', isFavoriteSignal.value);
     })();
   });
   ```

NOTA:

- El cuerpo de `useTask$` se ejecuta tanto en el servidor como en el cliente (isom贸rfico).
- En SSR, el servidor imprime `FAVORITE (isomorphic) false` y `FAVORITE (server) false`.
- Cuando el usuario interact煤a con `favorite`, el cliente imprime `FAVORITE (isomorphic) true` y el servidor imprime `FAVORITE (server) true`.

Para referencia, el c贸digo completo de esta secci贸n es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/05-tasks/index.tsx" style={{ height: '10em' }} maxHeight={500}>
```tsx {28-34} title="src/routes/joke/index.tsx"
import { component$, useSignal, useTask$ } from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          
        </button>
        <button name="vote" value="down">
          
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? 'わ' : ''}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 6. Estilos

Estilos es una parte importante de cualquier aplicaci贸n. Qwik proporciona una forma de asociar y delimitar el alcance de los estilos con su componente.

Para agrega estilos:

1. Crea un nuevo archivo `src/routes/joke/index.css`:

   ```css
   p {
     font-weight: bold;
   }

   form {
     float: right;
   }
   ```

2. importa los estilos en `src/routes/joke/index.tsx`:
    ```tsx
    import STYLES from "./index.css?inline";
    ```
3. Dile al componente que cargue los estilos:
   ```tsx
   useStylesScoped$(STYLES);
   ```

Explicaci贸n del c贸digo:

- El par谩metro de consulta `?inline` le indica a Vite que incruste los estilos en el componente.
- La llamada `useStylesScoped$` le indica a Qwik que asocie los estilos solo con el componente (delimitaci贸n de alcance).
- Los estilos se cargan solo si no est谩n incrustados como parte de SSR y solo para el primer componente.

Para referencia, el c贸digo completo de esta secci贸n es el siguiente:

<CodeSandbox maxHeight={500} src="/src/routes/demo/getting-started/06-styling/index.tsx" style={{ height: '10em' }}>
```tsx /useStylesScoped\$/ title="src/routes/joke/index.tsx"
import {
  component$,
  useSignal,
  useStylesScoped$,
  useTask$,
} from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';
import STYLES from './index.css?inline';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  useStylesScoped$(STYLES);
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up"></button>
        <button name="vote" value="down"></button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? 'わ' : ''}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 7. Vista Previa

Construimos una aplicaci贸n m铆nima que le brind贸 una descripci贸n general de los conceptos y API clave de Qwik. La aplicaci贸n se est谩 ejecutando en modo de desarrollo, que utiliza la recarga de m贸dulos en caliente (HMR) para actualizar continuamente la aplicaci贸n mientras se cambia el c贸digo.
Mientras en modo de desarrollo:

- Cada archivo se carga individualmente, lo que puede causar carga en cascada en la pesta帽a de red.
- No hay carga especulativa de paquetes, por lo que puede haber un retraso en la primera interacci贸n.

Vamos a crear una compilaci贸n de producci贸n que elimine estos problemas.

Para crear una compilaci贸n de vista previa:

1. Ejecuta `npm run preview` para crear una compilaci贸n de producci贸n.

NOTA:

- Tu aplicaci贸n debe tener una compilaci贸n de producci贸n ahora y estar ejecut谩ndose en un puerto diferente.
- Si interact煤a con la aplicaci贸n ahora, la pesta帽a de red de las herramientas de desarrollo debe mostrar que los paquetes se entregan instant谩neamente desde la [cach茅 del ServiceWorker](/docs/(qwikcity)/advanced/speculative-module-fetching/index.mdx).

## Revisiones

Felicidades! Has aprendido mucho sobre Qwik!
Para obtener m谩s informaci贸n sobre todo lo que puedes lograr con Qwik, te recomendamos leer la documentaci贸n dedicada a cada uno de los temas tratados en este tutorial:

- [Project structure](/docs/(qwikcity)/project-structure/index.mdx):
- [Directory-based](/docs/(qwikcity)/routing/index.mdx) routing
- [Component](/docs/(qwik)/components/overview/index.mdx)
- [Route loaders](/docs/(qwikcity)/route-loader/index.mdx)
- [Form actions](/docs/(qwikcity)/action/index.mdx) (and [zod validation](/docs/(qwikcity)/action/index.mdx#zod-validation))
- [State management](/docs/(qwik)/components/state/index.mdx)
- [Tasks](/docs/(qwik)/components/tasks/index.mdx#use-usetask-when-you-need-to)
- [ServiceWorker cache](/docs/(qwikcity)/advanced/speculative-module-fetching/index.mdx#pre-populating-the-cache-with-a-service-worker)
