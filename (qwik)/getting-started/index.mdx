---
title: Getting Started
contributors:
  - manucorporat
  - jesperp
  - adamdbradley
  - steve8708
  - cunzaizhuyi
  - mousaAM
  - zanettin
  - Craiqser
  - MyltsinVV
  - literalpie
  - colynyu
  - the-r3aper7
  - ahmadalfy
  - renomureza
  - mhevery
  - AnthonyPAlicea
  - kapunahelewong
  - kushalmahajan
  - sreeisalso
  - dustinsgoodman
---

import CodeSandbox from '../../../../components/code-sandbox/index.tsx';

# Comenzando rápidamente con Qwik
Qwik es un nuevo tipo de framework que es [reanudable](../concepts/resumable/index.mdx) (sin ejecución de JS precipitada y sin hidratación), construido para edge y [familiar para desarrolladores React](/docs/integrations/react/index.mdx).

Para empezar a usarlo de inmediato, echa un vistazo a nuestro playground en el navegador:

- [StackBlitz Qwik](https://qwik.new) (Qwik Completo + integracion con Qwikcity)
- [Playground de Ejemplos](/examples/reactivity/counter/) (Solo Qwik, sin enrutado)

## Pre-requisitos

Para comenzar con Qwik localmente, necesitas lo siguiente:

- [Node.js v16.8](https://nodejs.org/en/download/) o superior
- Tu IDE favorito ([vscode](https://code.visualstudio.com/) recomendado)
- Opcionalmente, lee [think qwik](../think-qwik/index.mdx)


## Crea una aplicación usando la CLI

Primero, crea una aplicación Qwik con la CLI de Qwik, que genera un inicio en blanco para que puedas familiarizarte rápidamente con él.

Ejecuta la CLI de Qwik en tu terminal. Qwik admite NPM, yarn y pnpm. Elige el gestor de paquetes que prefieras y ejecuta uno de los siguientes comandos:

```shell
npm create qwik@latest
pnpm create qwik@latest
yarn create qwik@latest
```

El CLI te guía a través de un menú interactivo para establecer el nombre del proyecto, seleccionar uno de los inicios y preguntará si quieres instalar las dependencias. Obtén más información sobre los archivos generados consultando la documentación de [Estructura del Proyecto](/docs/project-structure/).

Inicia el servidor de desarrollo:

```shell
npm start
pnpm start
yarn start
```

## Qwik Chiste App

El tutorial de Qwik Hello World te guía a través de la construcción de una aplicación de chiste con Qwik mientras cubre los conceptos más importantes de Qwik. La aplicación muestra un chiste aleatorio de https://icanhazdadjoke.com y cuenta con un botón para obtener un nuevo chiste al hacer clic.

### 1. Crea una ruta

Comienza sirviendo una página en una ruta en particular. Esta aplicación básica sirve una aplicación de chiste aleatorio en la ruta `/joke/`. Este tutorial se basa en Qwikcity, el meta-framework de Qwik, que utiliza [directory-based](/docs/(qwikcity)/routing/index.mdx) routing. Para comenzar:

1. En tu proyecto, crea un nuevo directorio `joke` en `routes` que contenga un archivo `index.tsx`.
2. Cada ruta `index.tsx` debe tener un `export default component$(...)` para que Qwikcity sepa qué contenido servir. Pega el siguiente contenido en `src/routes/joke/index.tsx`:

<CodeSandbox src="/src/routes/demo/getting-started/01-route/index.tsx" style={{ height: '6em' }}>
```tsx {3-5} title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <section class="section bright">A Joke!</section>;
});
```
</CodeSandbox>

3. Navega a `http://127.0.0.1:5173/joke/` para ver tu nueva página funcionando.

> NOTA:
>
> - Tu componente de ruta `joke` predeterminado está rodeado de un diseño existente. Consulta [Layout](/docs/layout/) para obtener más detalles sobre qué son los diseños y cómo trabajar con ellos.
> - Para mas detalles sobre como escribir componentes, consulta la sección [Component API](/docs/(qwik)/components/overview/index.mdx).

### 2. Cargando Datos

Vamos a usar la API JSON externa en https://icanhazdadjoke.com para cargar chistes aleatorios. Usaremos [route loaders](/docs/(qwikcity)/route-loader/index.mdx) para cargar estos datos en el servidor y luego representarlos en el componente.

1. Abre `src/routes/joke/index.tsx` y agrega este código:

```tsx /routeLoader\$/ title="src/routes/joke/index.tsx"
<CodeSandbox src="/src/routes/demo/getting-started/02-loading-data/index.tsx" style={{ height: '6em' }}>
```tsx /routeLoader$/ /useDadJoke/#a title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export default component$(() => {
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
    </section>
  );
});
```
</CodeSandbox>

2. Now en `http://localhost:5173/joke/`, el navegador muestra un chiste aleatorio.
Explicación del código:

- La función pasada a `routeLoader$` se invoca en el servidor antes de que se renderice cualquier componente y es responsable de cargar los datos.
- El `routeLoader$` devuelve un use-hook, `useDadJoke()`, que se puede usar en el componente para recuperar los datos del servidor.

> **NOTA**
>
> - El `routeLoader$` es invocado precipitadamente en el servidor antes de que se renderice cualquier componente, incluso si su use-hook no se invoca en ningún componente.
> - El tipo de retorno de `routeLoader$` se infiere en el componente sin necesidad de información de tipo adicional.


### 3. Enviando datos al servidor

Anteriormente, usamos `routeLoader$` para enviar datos del servidor al cliente. Para publicar (enviar) datos del cliente al servidor, usamos [`routeAction$`](/docs/(qwikcity)/action/index.mdx).

NOTA: `routeAction$` es la forma preferida de enviar datos al servidor porque utiliza la API de formulario nativa del navegador, que funciona incluso si JavaScript está deshabilitado.
Para declarar una acción, agrega este código:


```tsx /routeAction\$/ title="src/routes/joke/index.tsx"
import { routeAction$, Form } from '@builder.io/qwik-city';

export const useJokeVoteAction = routeAction$((props) => {
  // Leave it as an exercise for the reader to implement this.
  console.log('VOTE', props);
});
```

2. Actualiza el componente `export default` para usar el use-hook `useJokeVoteAction` con `<Form>`.

```tsx {3,7-11} /favoriteJokeAction/ title="src/routes/joke/index.tsx"
export default component$(() => {
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
    </section>
  );
});
```

3. Ahora en `http://localhost:5173/joke/`, los botones se muestran y si haces clic en ellos, su valor se registra en la consola.

Explicación del código:

- `routeAction$` recibe los datos.
  - La función pasada a `routeAction$` se invoca en el servidor cada vez que se publica el formulario.
  - El `routeAction$` devuelve un use-hook, `useJokeVoteAction`, que se puede usar en el componente para publicar los datos del formulario.
- `Form` es un componente de conveniencia que envuelve el elemento nativo `<form>` del navegador.


Cosas a tener en cuenta:

- Para la validación, consulte [zod validation](/docs/(qwikcity)/action/index.mdx#zod-validation).
- El `routeAction$` funciona incluso si JavaScript está deshabilitado.
- Si JavaScript está habilitado, el componente `Form` evitará que el navegador publique el formulario y, en su lugar, publicará los datos usando JavaScript y emulará el comportamiento nativo del formulario del navegador sin una actualización completa.

Para referencia, el código completo de esta sección es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/03-posting-data/index.tsx" style={{ height: '8em' }}>
```tsx {21,25-29} /favoriteJokeAction/ title="src/routes/joke/index.tsx"
import { component$ } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          👍
        </button>
        <button name="vote" value="down">
          👎
        </button>
      </Form>
    </section>
  );
});
```
</CodeSandbox>

### 4. Modificando el estado

El seguimiento del estado y la actualización de la interfaz de usuario es fundamental para lo que hacen las aplicaciones. Qwik proporciona un gancho `useSignal` para realizar un seguimiento del estado de la aplicación. Para obtener más información, consulte [state management](/docs/components/state/).

Para declarar el estado:

1. Import `useSignal` from `qwik`.
   ```tsx /useSignal/
   import { component$, useSignal } from "@builder.io/qwik";
   ```
2. Declare the component's state using `useSignal()`.
   ```tsx /useSignal/
   const isFavoriteSignal = useSignal(false);
   ```
3. After the closing `Form` tag, add a button to the component to modify the state.
   ```tsx /isFavoriteSignal/
   <button
    onClick$={() => {
      isFavoriteSignal.value = !isFavoriteSignal.value;
    }}>
     {isFavoriteSignal.value ? '❤️' : '🤍'}
   </button>
   ```

NOTA: Al hacer clic en el botón se actualiza el estado, que a su vez actualiza la interfaz de usuario.

Para referencia, el código completo de esta sección es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/04-state/index.tsx" style={{ height: '10em' }} maxHeight={500}>
```tsx /isFavoriteSignal/ title="src/routes/joke/index.tsx"
import { component$, useSignal } from '@builder.io/qwik';
import { routeLoader$, Form, routeAction$ } from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();

  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          👍
        </button>
        <button name="vote" value="down">
          👎
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 5. Tareas e Invocación de Código del Servidor

En Qwik, una [tarea](/docs/components/tasks/#usetask) es un trabajo que debe realizarse cuando cambia un estado. (Esto es similar a un "efecto" en otros frameworks.) En este ejemplo, usamos la tarea para invocar código en el servidor.

1. Cree una nueva tarea que realice un seguimiento del estado de `isFavoriteSignal`:
   ```tsx /useTask\$/
   useTask$(({ track }) => {});
   ```
2. Agregue una llamada `track` para volver a ejecutar la tarea en el cambio de estado de `isFavoriteSignal`:
   ```tsx /track/
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
   });
   ```
3. Agregue el trabajo que desea ejecutar en el cambio de estado:
   ```tsx {3}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
   });
   ```
4. Si desea que el trabajo se realice solo en el servidor, envuélvalo en `server$()`
   ```tsx /server\$/ {4-6}
   useTask$(({ track }) => {
     track(()=> isFavoriteSignal.value);
     console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
     server$(() => {
       console.log('FAVORITE (server)', isFavoriteSignal.value);
     })();
   });
   ```

NOTA:

- El cuerpo de `useTask$` se ejecuta tanto en el servidor como en el cliente (isomórfico).
- En SSR, el servidor imprime `FAVORITE (isomorphic) false` y `FAVORITE (server) false`.
- Cuando el usuario interactúa con `favorite`, el cliente imprime `FAVORITE (isomorphic) true` y el servidor imprime `FAVORITE (server) true`.

Para referencia, el código completo de esta sección es el siguiente:

<CodeSandbox src="/src/routes/demo/getting-started/05-tasks/index.tsx" style={{ height: '10em' }} maxHeight={500}>
```tsx {28-34} title="src/routes/joke/index.tsx"
import { component$, useSignal, useTask$ } from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">
          👍
        </button>
        <button name="vote" value="down">
          👎
        </button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 6. Estilos

Estilos es una parte importante de cualquier aplicación. Qwik proporciona una forma de asociar y delimitar el alcance de los estilos con su componente.

Para agrega estilos:

1. Crea un nuevo archivo `src/routes/joke/index.css`:

   ```css
   p {
     font-weight: bold;
   }

   form {
     float: right;
   }
   ```

2. importa los estilos en `src/routes/joke/index.tsx`:
    ```tsx
    import STYLES from "./index.css?inline";
    ```
3. Dile al componente que cargue los estilos:
   ```tsx
   useStylesScoped$(STYLES);
   ```

Explicación del código:

- El parámetro de consulta `?inline` le indica a Vite que incruste los estilos en el componente.
- La llamada `useStylesScoped$` le indica a Qwik que asocie los estilos solo con el componente (delimitación de alcance).
- Los estilos se cargan solo si no están incrustados como parte de SSR y solo para el primer componente.

Para referencia, el código completo de esta sección es el siguiente:

<CodeSandbox maxHeight={500} src="/src/routes/demo/getting-started/06-styling/index.tsx" style={{ height: '10em' }}>
```tsx /useStylesScoped\$/ title="src/routes/joke/index.tsx"
import {
  component$,
  useSignal,
  useStylesScoped$,
  useTask$,
} from '@builder.io/qwik';
import {
  routeLoader$,
  Form,
  routeAction$,
  server$,
} from '@builder.io/qwik-city';
import STYLES from './index.css?inline';

export const useDadJoke = routeLoader$(async () => {
  const response = await fetch('https://icanhazdadjoke.com/', {
    headers: { Accept: 'application/json' },
  });
  return (await response.json()) as {
    id: string;
    status: number;
    joke: string;
  };
});

export const useJokeVoteAction = routeAction$((props) => {
  console.log('VOTE', props);
});

export default component$(() => {
  useStylesScoped$(STYLES);
  const isFavoriteSignal = useSignal(false);
  // Calling our `useDadJoke` hook, will return a reactive signal to the loaded data.
  const dadJokeSignal = useDadJoke();
  const favoriteJokeAction = useJokeVoteAction();
  useTask$(({ track }) => {
    track(() => isFavoriteSignal.value);
    console.log('FAVORITE (isomorphic)', isFavoriteSignal.value);
    server$(() => {
      console.log('FAVORITE (server)', isFavoriteSignal.value);
    })();
  });
  return (
    <section class="section bright">
      <p>{dadJokeSignal.value.joke}</p>
      <Form action={favoriteJokeAction}>
        <input type="hidden" name="jokeID" value={dadJokeSignal.value.id} />
        <button name="vote" value="up">👍</button>
        <button name="vote" value="down">👎</button>
      </Form>
      <button
        onClick$={() => (isFavoriteSignal.value = !isFavoriteSignal.value)}
      >
        {isFavoriteSignal.value ? '❤️' : '🤍'}
      </button>
    </section>
  );
});
```
</CodeSandbox>

### 7. Vista Previa

Construimos una aplicación mínima que le brindó una descripción general de los conceptos y API clave de Qwik. La aplicación se está ejecutando en modo de desarrollo, que utiliza la recarga de módulos en caliente (HMR) para actualizar continuamente la aplicación mientras se cambia el código.
Mientras en modo de desarrollo:

- Cada archivo se carga individualmente, lo que puede causar carga en cascada en la pestaña de red.
- No hay carga especulativa de paquetes, por lo que puede haber un retraso en la primera interacción.

Vamos a crear una compilación de producción que elimine estos problemas.

Para crear una compilación de vista previa:

1. Ejecuta `npm run preview` para crear una compilación de producción.

NOTA:

- Tu aplicación debe tener una compilación de producción ahora y estar ejecutándose en un puerto diferente.
- Si interactúa con la aplicación ahora, la pestaña de red de las herramientas de desarrollo debe mostrar que los paquetes se entregan instantáneamente desde la [caché del ServiceWorker](/docs/(qwikcity)/advanced/speculative-module-fetching/index.mdx).

## Revisiones

Felicidades! Has aprendido mucho sobre Qwik!
Para obtener más información sobre todo lo que puedes lograr con Qwik, te recomendamos leer la documentación dedicada a cada uno de los temas tratados en este tutorial:

- [Project structure](/docs/(qwikcity)/project-structure/index.mdx):
- [Directory-based](/docs/(qwikcity)/routing/index.mdx) routing
- [Component](/docs/(qwik)/components/overview/index.mdx)
- [Route loaders](/docs/(qwikcity)/route-loader/index.mdx)
- [Form actions](/docs/(qwikcity)/action/index.mdx) (and [zod validation](/docs/(qwikcity)/action/index.mdx#zod-validation))
- [State management](/docs/(qwik)/components/state/index.mdx)
- [Tasks](/docs/(qwik)/components/tasks/index.mdx#use-usetask-when-you-need-to)
- [ServiceWorker cache](/docs/(qwikcity)/advanced/speculative-module-fetching/index.mdx#pre-populating-the-cache-with-a-service-worker)
