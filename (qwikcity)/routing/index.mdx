---
title: Qwik City - Routing
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
  - wtlin1228
  - AnthonyPAlicea
---

# Enrutamiento

El enrutamiento en Qwik City se basa en el sistema de archivos, similar a [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/core-concepts/routing) o [Remix](https://remix.run/docs/en/main/guides/routing). Los archivos y directorios en `src/routes` desempe√±an un papel en el enrutamiento de tu aplicaci√≥n.

- **üìÇ Directorios:** Describen los segmentos de URL que deben coincidir con el enrutador.
- **üìÑ Ficheros index:** P√°gina/endpoint.
- **üñºÔ∏è Ficheros layout:** Layout anidados/middleware.

## Enrutamiento basado en directorios

Solo se utilizan los nombres de los directorios para hacer coincidir las solicitudes entrantes con las p√°ginas/endpoints.

Por ejemplo, si tenemos un archivo en la ruta `src/routes/some/path/index.tsx`, se asignar√° a la ruta la URL `https://example.com/some/path`.

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ contact/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.mdx         # https://example.com/contact
    ‚îú‚îÄ‚îÄ about/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.md          # https://example.com/about
    ‚îú‚îÄ‚îÄ docs/
    ‚îÇ   ‚îî‚îÄ‚îÄ [id]/
    ‚îÇ       ‚îî‚îÄ‚îÄ index.ts      # https://example.com/docs/1234
    ‚îÇ                         # https://example.com/docs/anything
    ‚îú‚îÄ‚îÄ [...catchall]/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx         # https://example.com/anything/else/that/didnt/match
    ‚îÇ
    ‚îî‚îÄ‚îÄ layout.tsx            # Este layout se usa en todas las p√°ginas
```

- **`[id]`** es un directorio que representa un segmento de ruta din√°mica, en este ejemplo, `id` es el par√°metro de cadena accesible mediante `getLocation().params.id`.
- **`[...catchall]`** es un directorio que representa una ruta din√°mica de captura de todo, en este ejemplo, `catchall` es el par√°metro de cadena accesible mediante `getLocation().params.catchall`.
- Los archivos **`index.tsx|mdx`** son las p√°ginas/endpoints.
- Los archivos **`layout.tsx`** son los layouts.

### Segmentos de ruta din√°micos

Directorios con nombres especiales entre corchetes, como `[paramName]` y `[...catchAll]`, se pueden utilizar para hacer coincidir segmentos de ruta que son din√°micos:

```
src/routes/blog/index.tsx ‚Üí /blog
src/routes/user/[username]/index.tsx ‚Üí /user/:username (/user/foo)
src/routes/post/[...all]/index.tsx ‚Üí /post/* (/post/2020/id/title)
```

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ blog/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx         # https://example.com/blog
    ‚îú‚îÄ‚îÄ post/
    ‚îÇ   ‚îî‚îÄ‚îÄ [...all]/
    ‚îÇ       ‚îî‚îÄ‚îÄ index.tsx     # https://example.com/post/2020/id/title
    ‚îî‚îÄ‚îÄ user/
        ‚îî‚îÄ‚îÄ [username]/
            ‚îî‚îÄ‚îÄ index.tsx     # https://example.com/user/foo
```

> La carpeta `[username]` puede representar a cualquiera de los miles de usuarios que tienes en tu base de datos. Ser√≠a poco pr√°ctico crear una ruta para cada usuario. En su lugar, debes definir un par√°metro de ruta (una parte de la URL) que se utilizar√° para extraer el `[username]`.

```tsx title="src/routes/user/[username]/index.tsx"
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>¬°Hola {loc.params.username}!</div>;
});
```

## Archivos `index.`

Dentro del directorio `src/routes`, todos los archivos con el nombre `index` se consideran p√°ginas/endpoints. Qwik admite las siguientes extensiones: `.ts`, `.tsx`, `.md` y `.mdx`.

Las p√°ginas/endpoints son los nodos hoja del √°rbol de enrutamiento, es decir, **los m√≥dulos que manejar√°n la solicitud y devolver√°n una respuesta HTTP**.

### P√°gina `index.tsx`

Cuando `index.tsx` o `index.ts` exporta un componente de Qwik como la exportaci√≥n predeterminada, Qwik City renderizar√° el componente y devolver√° una respuesta HTML como una p√°gina web.

```tsx title="src/routes/index.tsx"
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hola mundo</h1>;
});
```

### Endpoint `index.ts`

Un archivo `index.ts` tambi√©n puede acceder directamente a la solicitud HTTP y devolver una respuesta HTTP en bruto sin involucrar ning√∫n componente de Qwik. Esto se hace exportando un m√©todo `onRequest` o `onGet`, `onPost`, `onPut`, `onDelete` dependiendo de si solo deseas manejar una solicitud espec√≠fica seg√∫n su m√©todo HTTP.

```tsx title="src/routes/index.ts"
import type { RequestHandler } from '@builder.io/qwik-city';

export const onGet: RequestHandler = ({ json }) => {
  json(200, { message: 'Hola mundo' });
};
```

> Observa que en el √∫ltimo ejemplo no hay una exportaci√≥n predeterminada. Esto se debe a que no estamos renderizando un componente de Qwik, sino que estamos manejando la solicitud directamente y devolviendo una respuesta JSON. Esto es √∫til para implementar APIs RESTful u cualquier otro tipo de punto final HTTP.

### P√°gina + Endpoint

Como puedes ver en Qwik City, no hay una separaci√≥n clara entre p√°ginas y endpoints, en ambos casos, es un archivo `index.tsx` que exporta un componente de Qwik o un m√©todo `onRequest`. Sin embargo, es posible combinar ambos enfoques. Por ejemplo, puedes exportar un m√©todo `onRequest` que maneje la solicitud y luego renderizar un componente de Qwik.

```tsx title="src/routes/index.tsx"
import { component$ } from '@builder.io/qwik';
import type { RequestHandler } from '@builder.io/qwik-city';

export const onRequest: RequestHandler = ({ headers, query, json }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hola mundo' });
  }
};

export default component$(() => {
  return <h1>Hola mundo</h1>;
});
```

> En este ejemplo, el manejador de solicitud siempre establecer√° el encabezado `Cache-Control` en `private` y la p√°gina se renderizar√° como una p√°gina HTML, pero si la solicitud contiene un par√°metro de consulta `format=json`, el endpoint devolver√° una respuesta JSON en su lugar.

## `layout.` files

Layout modules are very similar to `index` files, both can handle requests and render Qwik components, however, layouts are designed to work like a middleware, allowing to **share UI and request handling (middleware)** to a set of routes.

Usually, different pages need some common request handling and share some UI. For example, picture a dashboard site where all the pages are under the `/admin/*` directory:

- **Shared request handling:** The request cookies need to be validated before even rendering the page, otherwise, render a blank 401 page.
- **Shared UI:** All pages share a common header showing the user's name and profile picture.

Instead of repeating the same code in each route, we can use layouts to automatically reuse common parts, and also to add middleware to the route.

Take this `src/routes` directory as an example:

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ admin/
    ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx  <-- This layout is used for all pages under /admin/*
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
    ‚îú‚îÄ‚îÄ layout.tsx      <-- This layout is used for all pages
    ‚îî‚îÄ‚îÄ index.tsx
```

### Middleware layouts

Since layouts can implement request handling with `onRequest` or `onGet`, `onPost`, `onPut`, `onDelete`, they can be used to implement middleware, for example, to validate the request cookies before rendering the page.

For the route `https://example.com/admin`, the `onRequest` methods will be executed in the following order:

1. `src/routes/layout.tsx`'s `onRequest`
2. `src/routes/admin/layout.tsx`'s `onRequest`
3. `src/routes/admin/index.tsx`'s component

### Nested layouts

Layouts also **provide a way to add common UI to the rendered page**. For example, if we want to add a common header to all the routes, we can add a `Header` component to the root layout.

For the given example, the Qwik components will be rendered in the following order:

1. `src/routes/layout.tsx`'s component
2. `src/routes/admin/layout.tsx`'s component
3. `src/routes/admin/index.tsx`'s component

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## SPA navigation

Qwik provides the `<Link>` component and the `useNavigate()` hook to refresh and navigate between pages.

The `Link` is usually the recommend way to navigate because it uses the HTML `<a>` tag, which is the most accessible way to navigate between pages.

However, if you need to navigate programmatically, you can use the `useNavigate()` hook.

```tsx
import { component$ } from '@builder.io/qwik';
import { Link, useNavigate } from '@builder.io/qwik-city';

export default component$(() => {
  const nav = useNavigate();
  return (
    <div>
      <Link href="/about">About (prefered)</Link>
      <button onClick$={() => nav('/about')}>About</button>
    </div>
  );
});
```

### Refreshing

You can use the `Link` with the `reload` prop to refresh the page.

You can also call the `nav()` function from the `useNavigate()` hook, without any arguments.

```tsx
import { component$ } from '@builder.io/qwik';
import { Link, routeLoader$, useNavigate } from '@builder.io/qwik-city';

export const useServerTime = routeLoader$(() => {
  // This will re-execute in the server when the page refreshes
  return Date.now();
});

export default component$(() => {
  const nav = useNavigate();
  const serverTime = useServerTime();

  return (
    <div>
      <Link reload>Refresh (better accesibility)</Link>
      <button onClick$={() => nav()}>Refresh</button>
      <p>Server time: {serverTime.value}</p>
    </div>
  );
});
```

> When the page refreshes, all the matching `routeLoader$` and server handlers (`onRequest`) will reexecute in the server and the UI will re-render accordingly.

> While refreshing the page, the `isNavigating` boolean from `useLocation()` will be `true` until the page is fully rendered.

## Request Event

Each request handler, such as `onRequest`, `onGet`, `onPost`, etc., are passed in a `RequestEvent` object as the first argument to the handler. The `RequestEvent` object contains utility functions and properties to get and set values to the server's request and response. This object contains the following properties:

- `basePathname`: The base pathname of the request, which can be configured at build time. Defaults to `/`.
- `cacheControl`: Convenience function to set the [Cache-Control](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control) response header.
- `cookie`: HTTP request and response [cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies). Use the `get()` method to retrieve a request cookie value. Use the `set()` method to set a response cookie value.
- `env`: Platform provided environment variables.
- `error`: When called, the response will immediately end with the given status code. This could be useful to end a response with `404`, and use the 404 handler in the routes directory. See [Status codes](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status) for which status code should be used.
- `getWritableStream`: Low-level access to write to the HTTP response stream. Once `getWritableStream()` is called, the status and headers can no longer be modified and will be sent over the network.
- `headers`: HTTP [response headers](https://developer.mozilla.org/en-US/docs/Glossary/Response_header).
- `html`: Convenience method to send an HTML body response. The response will be automatically set the `Content-Type` header to`text/html; charset=utf-8`. An `html()` response can only be called once.
- `json`: Convenience method to JSON stringify the data and send it in the response. The response will be automatically set the `Content-Type` header to`application/json; charset=utf-8`. A `json()` response can only be called once.
- `locale`: Which locale the content is in. The locale value can be retrieved from selected methods using `getLocale()`.
- `method`: HTTP request [method](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods) value.
- `next`: Call the next request handler. This is useful for middleware.
- `params`: URL path params which have been parsed from the current url pathname segments. Use `query` to instead retrieve the query string search params.
- `parseBody`: This method will check the request headers for a `Content-Type` header and parse the body accordingly. It supports `application/json`, `application/x-www-form-urlencoded`, and `multipart/form-data` content types. If the `Content-Type` header is not set, it will return `null`.
- `pathname`: URL pathname value. Does not include the protocol, domain, query string (search params) or hash.
- `platform`: Platform specific data and functions.
- `query`: URL query string [URLSearchParams](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) value. Use `params` to instead retrieve the route params found in the url pathname.
- `redirect`: URL to redirect to. When called, the response will immediately end with the correct redirect status and headers. See [Redirects](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) for which status code should be used.
- `request`: HTTP [Request](https://developer.mozilla.org/en-US/docs/Web/API/Request).
- `send`: Send a body response. The `Content-Type` response header is not automatically set when using `send()` and must be set manually. A `send()` response can only be called once.
- `sharedMap`: Shared Map across all the request handlers. Every HTTP request will get a new instance of the shared map. The shared map is useful for sharing data between request handlers.
- `status`: HTTP response [status code](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status). Sets the status code when called with an argument. Always returns the status code, so calling `status()` without an argument will can be used to return the current status code.
- `text`: Convenience method to send an text body response. The response will be automatically set the `Content-Type` header to`text/plain; charset=utf-8`. An `text()` response can only be called once.
- `url`: HTTP request [URL](https://developer.mozilla.org/en-US/docs/Web/API/URL).

## Enrutamiento avanzado

Qwik City tambi√©n admite las siguientes caracter√≠sticas de enrutamiento avanzado:

- [Par√°metros de ruta](/docs/(qwikcity)/advanced/routing/index.mdx)
- [Dise√±os anidados](/docs/(qwikcity)/advanced/routing/index.mdx#nested-layout)
- [Men√∫s](/docs/(qwikcity)/advanced/menu/index.mdx)

Estos temas se discuten en detalle m√°s adelante. Puedes obtener m√°s informaci√≥n sobre estas caracter√≠sticas en los enlaces proporcionados.
