---
title: Qwik City - Routing
contributors:
  - manucorporat
  - nnelgxorz
  - the-r3aper7
  - Oyemade
  - mhevery
  - adamdbradley
  - wtlin1228
  - AnthonyPAlicea
---

# Enrutamiento

El enrutamiento en Qwik City se basa en el sistema de archivos, similar a [Next.js](https://nextjs.org/docs/routing/introduction), [SvelteKit](https://kit.svelte.dev/docs/routing), [SolidStart](https://start.solidjs.com/core-concepts/routing) o [Remix](https://remix.run/docs/en/main/guides/routing). Los archivos y directorios en `src/routes` desempe√±an un papel en el enrutamiento de tu aplicaci√≥n.

- **üìÇ Directorios:** Describen los segmentos de URL que deben coincidir con el enrutador.
- **üìÑ Ficheros index:** P√°gina/endpoint.
- **üñºÔ∏è Ficheros layout:** Layout anidados/middleware.

## Enrutamiento basado en directorios

Solo se utilizan los nombres de los directorios para hacer coincidir las solicitudes entrantes con las p√°ginas/endpoints.

Por ejemplo, si tenemos un archivo en la ruta `src/routes/some/path/index.tsx`, se asignar√° a la ruta la URL `https://example.com/some/path`.

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ contact/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.mdx         # https://example.com/contact
    ‚îú‚îÄ‚îÄ about/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.md          # https://example.com/about
    ‚îú‚îÄ‚îÄ docs/
    ‚îÇ   ‚îî‚îÄ‚îÄ [id]/
    ‚îÇ       ‚îî‚îÄ‚îÄ index.ts      # https://example.com/docs/1234
    ‚îÇ                         # https://example.com/docs/anything
    ‚îú‚îÄ‚îÄ [...catchall]/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx         # https://example.com/anything/else/that/didnt/match
    ‚îÇ
    ‚îî‚îÄ‚îÄ layout.tsx            # Este layout se usa en todas las p√°ginas
```

- **`[id]`** es un directorio que representa un segmento de ruta din√°mica, en este ejemplo, `id` es el par√°metro de cadena accesible mediante `getLocation().params.id`.
- **`[...catchall]`** es un directorio que representa una ruta din√°mica de captura de todo, en este ejemplo, `catchall` es el par√°metro de cadena accesible mediante `getLocation().params.catchall`.
- Los archivos **`index.tsx|mdx`** son las p√°ginas/endpoints.
- Los archivos **`layout.tsx`** son los layouts.

### Segmentos de ruta din√°micos

Directorios con nombres especiales entre corchetes, como `[paramName]` y `[...catchAll]`, se pueden utilizar para hacer coincidir segmentos de ruta que son din√°micos:

```
src/routes/blog/index.tsx ‚Üí /blog
src/routes/user/[username]/index.tsx ‚Üí /user/:username (/user/foo)
src/routes/post/[...all]/index.tsx ‚Üí /post/* (/post/2020/id/title)
```

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ blog/
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx         # https://example.com/blog
    ‚îú‚îÄ‚îÄ post/
    ‚îÇ   ‚îî‚îÄ‚îÄ [...all]/
    ‚îÇ       ‚îî‚îÄ‚îÄ index.tsx     # https://example.com/post/2020/id/title
    ‚îî‚îÄ‚îÄ user/
        ‚îî‚îÄ‚îÄ [username]/
            ‚îî‚îÄ‚îÄ index.tsx     # https://example.com/user/foo
```

> La carpeta `[username]` puede representar a cualquiera de los miles de usuarios que tienes en tu base de datos. Ser√≠a poco pr√°ctico crear una ruta para cada usuario. En su lugar, debes definir un par√°metro de ruta (una parte de la URL) que se utilizar√° para extraer el `[username]`.

```tsx title="src/routes/user/[username]/index.tsx"
import { component$ } from '@builder.io/qwik';
import { useLocation } from '@builder.io/qwik-city';

export default component$(() => {
  const loc = useLocation();
  return <div>¬°Hola {loc.params.username}!</div>;
});
```

## Archivos `index.`

Dentro del directorio `src/routes`, todos los archivos con el nombre `index` se consideran p√°ginas/endpoints. Qwik admite las siguientes extensiones: `.ts`, `.tsx`, `.md` y `.mdx`.

Las p√°ginas/endpoints son los nodos hoja del √°rbol de enrutamiento, es decir, **los m√≥dulos que manejar√°n la solicitud y devolver√°n una respuesta HTTP**.

### P√°gina `index.tsx`

Cuando `index.tsx` o `index.ts` exporta un componente de Qwik como la exportaci√≥n predeterminada, Qwik City renderizar√° el componente y devolver√° una respuesta HTML como una p√°gina web.

```tsx title="src/routes/index.tsx"
import { component$ } from '@builder.io/qwik';

export default component$(() => {
  return <h1>Hola mundo</h1>;
});
```

### Endpoint `index.ts`

Un archivo `index.ts` tambi√©n puede acceder directamente a la solicitud HTTP y devolver una respuesta HTTP en bruto sin involucrar ning√∫n componente de Qwik. Esto se hace exportando un m√©todo `onRequest` o `onGet`, `onPost`, `onPut`, `onDelete` dependiendo de si solo deseas manejar una solicitud espec√≠fica seg√∫n su m√©todo HTTP.

```tsx title="src/routes/index.ts"
import type { RequestHandler } from '@builder.io/qwik-city';

export const onGet: RequestHandler = ({ json }) => {
  json(200, { message: 'Hola mundo' });
};
```

> Observa que en el √∫ltimo ejemplo no hay una exportaci√≥n predeterminada. Esto se debe a que no estamos renderizando un componente de Qwik, sino que estamos manejando la solicitud directamente y devolviendo una respuesta JSON. Esto es √∫til para implementar APIs RESTful u cualquier otro tipo de endpoint HTTP.

### P√°gina + Endpoint

Como puedes ver en Qwik City, no hay una separaci√≥n clara entre p√°ginas y endpoints, en ambos casos, es un archivo `index.tsx` que exporta un componente de Qwik o un m√©todo `onRequest`. Sin embargo, es posible combinar ambos enfoques. Por ejemplo, puedes exportar un m√©todo `onRequest` que maneje la solicitud y luego renderizar un componente de Qwik.

```tsx title="src/routes/index.tsx"
import { component$ } from '@builder.io/qwik';
import type { RequestHandler } from '@builder.io/qwik-city';

export const onRequest: RequestHandler = ({ headers, query, json }) => {
  headers.set('Cache-Control', 'private');
  if (query.get('format') === 'json') {
    json(200, { message: 'Hola mundo' });
  }
};

export default component$(() => {
  return <h1>Hola mundo</h1>;
});
```

> En este ejemplo, el manejador de solicitud siempre establecer√° el encabezado `Cache-Control` en `private` y la p√°gina se renderizar√° como una p√°gina HTML, pero si la solicitud contiene un par√°metro de consulta `format=json`, el endpoint devolver√° una respuesta JSON en su lugar.

## Archivos `layout.`

Los m√≥dulos de layout son muy similares a los archivos `index`, ambos pueden manejar solicitudes y renderizar componentes de Qwik. Sin embargo, los layouts est√°n dise√±ados para funcionar como middleware, permitiendo **compartir UI y manejo de solicitudes (middleware)** para un conjunto de rutas.

Por lo general, diferentes p√°ginas necesitan alg√∫n manejo com√∫n de solicitudes y comparten alguna UI. Por ejemplo, imagina un sitio de panel de control donde todas las p√°ginas se encuentran bajo el directorio `/admin/*`:

- **Manejo compartido de solicitudes:** Las cookies de la solicitud deben validarse antes de renderizar la p√°gina, de lo contrario, se muestra una p√°gina en blanco con un c√≥digo de error 401.
- **UI compartida:** Todas las p√°ginas comparten un encabezado com√∫n que muestra el nombre del usuario y su foto de perfil.

En lugar de repetir el mismo c√≥digo en cada ruta, podemos utilizar los layouts para reutilizar autom√°ticamente las partes comunes y tambi√©n agregar middleware a la ruta.

Tomemos como ejemplo el directorio `src/routes`:

```bash
src/
‚îî‚îÄ‚îÄ routes/
    ‚îú‚îÄ‚îÄ admin/
    ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx  <-- Este layout se utiliza para todas las p√°ginas bajo /admin/*
    ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
    ‚îú‚îÄ‚îÄ layout.tsx      <-- Este layout se utiliza para todas las p√°ginas
    ‚îî‚îÄ‚îÄ index.tsx
```

### Middleware en los layouts

Dado que los layouts pueden implementar el manejo de solicitudes con `onRequest` o `onGet`, `onPost`, `onPut`, `onDelete`, se pueden utilizar para implementar middleware, por ejemplo, para validar las cookies de la solicitud antes de renderizar la p√°gina.

Para la ruta `https://example.com/admin`, los m√©todos `onRequest` se ejecutar√°n en el siguiente orden:

1. `onRequest` de `src/routes/layout.tsx`
2. `onRequest` de `src/routes/admin/layout.tsx`
3. Componente de `src/routes/admin/index.tsx`

### Layouts anidados

Los layouts tambi√©n **proporcionan una forma de agregar UI com√∫n a la p√°gina renderizada**. Por ejemplo, si queremos agregar un encabezado com√∫n a todas las rutas, podemos agregar un componente `Header` al layout ra√≠z.

Para el ejemplo dado, los componentes de Qwik se renderizar√°n en el siguiente orden:

1. Componente de `src/routes/layout.tsx`
2. Componente de `src/routes/admin/layout.tsx`
3. Componente de `src/routes/admin/index.tsx`

```tsx
<RootLayout>
  <AdminLayout>
    <AdminPage />
  </AdminLayout>
</RootLayout>
```

## Navegaci√≥n en SPA

Qwik proporciona el componente `<Link>` y el hook `useNavigate()` para actualizar y navegar entre p√°ginas.

El `Link` es generalmente la forma recomendada de navegar porque utiliza la etiqueta HTML `<a>`, que es la forma m√°s accesible de navegar entre p√°ginas.

Sin embargo, si necesitas navegar de forma program√°tica, puedes utilizar el hook `useNavigate()`.

```tsx
import { component$ } from '@builder.io/qwik';
import { Link, useNavigate } from '@builder.io/qwik-city';

export default component$(() => {
  const nav = useNavigate();
  return (
    <div>
      <Link href="/about">Acerca de (preferido)</Link>
      <button onClick$={() => nav('/about')}>Acerca de</button>
    </div>
  );
});
```

### Actualizaci√≥n de la p√°gina

Puedes utilizar el `Link` con la propiedad `reload` para refrescar la p√°gina.

Tambi√©n puedes llamar a la funci√≥n `nav()` del hook `useNavigate()` sin ning√∫n argumento.

```tsx
import { component$ } from '@builder.io/qwik';
import { Link, routeLoader$, useNavigate } from '@builder.io/qwik-city';

export const useServerTime = routeLoader$(() => {
  // Esto se ejecutar√° nuevamente en el servidor cuando se refresque la p√°gina
  return Date.now();
});

export default component$(() => {
  const nav = useNavigate();
  const serverTime = useServerTime();

  return (
    <div>
      <Link reload>Refrescar (mejor accesibilidad)</Link>
      <button onClick$={() => nav()}>Refrescar</button>
      <p>Hora del servidor: {serverTime.value}</p>
    </div>
  );
});
```

> Cuando se refresca la p√°gina, todos los `routeLoader$` coincidentes y los manejadores del servidor (`onRequest`) se ejecutar√°n nuevamente en el servidor y la interfaz de usuario se volver√° a renderizar en consecuencia.

> Mientras se refresca la p√°gina, el booleano `isNavigating` de `useLocation()` ser√° `true` hasta que la p√°gina se haya renderizado por completo.

## Evento de solicitud

Cada manejador de solicitud, como `onRequest`, `onGet`, `onPost`, etc., recibe como primer argumento un objeto `RequestEvent`. El objeto `RequestEvent` contiene funciones de utilidad y propiedades para obtener y establecer valores en la solicitud y respuesta del servidor. Este objeto contiene las siguientes propiedades:

- `basePathname`: El pathname base de la solicitud, que se puede configurar en tiempo de compilaci√≥n. Por defecto es `/`.
- `cacheControl`: Funci√≥n de conveniencia para establecer el encabezado de respuesta [Cache-Control](https://developer.mozilla.org/es/docs/Web/HTTP/Headers/Cache-Control).
- `cookie`: Cookies de la solicitud HTTP y de respuesta [cookies](https://developer.mozilla.org/es/docs/Web/HTTP/Cookies). Utiliza el m√©todo `get()` para obtener el valor de una cookie de la solicitud. Utiliza el m√©todo `set()` para establecer el valor de una cookie de respuesta.
- `env`: Variables de entorno proporcionadas por la plataforma.
- `error`: Cuando se llama, la respuesta finalizar√° inmediatamente con el c√≥digo de estado proporcionado. Esto puede ser √∫til para finalizar una respuesta con `404` y utilizar el manejador de 404 en el directorio de rutas. Consulta los [c√≥digos de estado](https://developer.mozilla.org/es/docs/Web/HTTP/Status) para saber qu√© c√≥digo de estado se debe utilizar.
- `getWritableStream`: Acceso de bajo nivel para escribir en el flujo de respuesta HTTP. Una vez que se llama a `getWritableStream()`, el estado y los encabezados ya no se pueden modificar y se enviar√°n a trav√©s de la red.
- `headers`: Encabezados de respuesta HTTP [headers](https://developer.mozilla.org/es/docs/Glossary/Response_header).
- `html`: M√©todo de conveniencia para enviar una respuesta con cuerpo HTML. La respuesta se establecer√° autom√°ticamente con el encabezado `Content-Type` en `text/html; charset=utf-8`. Solo se puede llamar a `html()` una vez.
- `json`: M√©todo de conveniencia para convertir a JSON los datos y enviarlos en la respuesta. La respuesta se establecer√° autom√°ticamente con el encabezado `Content-Type` en `application/json; charset=utf-8`. Solo se puede llamar a `json()` una vez.
- `locale`: Idioma en el que se encuentra el contenido. El valor de idioma se puede obtener de ciertos m√©todos utilizando `getLocale()`.
- `method`: Valor del m√©todo de solicitud HTTP [method](https://developer.mozilla.org/es/docs/Web/HTTP/Methods).
- `next`: Llama al siguiente manejador de solicitud. Esto es √∫til para middleware.
- `params`: Par√°metros de la ruta URL que se han analizado a partir de los segmentos de pathname de la URL actual. Utiliza `query` para recuperar en su lugar los par√°metros de b√∫squeda de la cadena de consulta.
- `parseBody`: Este m√©todo verificar√° los encabezados de la solicitud en busca de un encabezado `Content-Type` y analizar√° el cuerpo en consecuencia. Admite los tipos de contenido `application/json`, `application/x-www-form-urlencoded` y `multipart/form-data`. Si no se establece el encabezado `Content-Type`, devolver√° `null`.
- `pathname`: Valor del pathname de la URL. No incluye el protocolo, dominio, cadena de b√∫squeda (par√°metros de b√∫squeda) ni fragmento.
- `platform`: Datos y funciones espec√≠ficos de la plataforma.
- `query`: Valor de la cadena de consulta URL [URLSearchParams](https://developer.mozilla.org/es/docs/Web/API/URLSearchParams). Utiliza `params` para recuperar en su lugar los par√°metros de ruta encontrados en el pathname de la URL.
- `redirect`: URL a la que redirigir. Cuando se llama, la respuesta finalizar√° inmediatamente con el c√≥digo de redirecci√≥n correcto y los encabezados adecuados. Consulta las [redirecciones](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections) para saber qu√© c√≥digo de estado se debe utilizar.
- `request`: Objeto de solicitud HTTP [Request](https://developer.mozilla.org/es/docs/Web/API/Request).
- `send`: Env√≠a una respuesta con cuerpo. El encabezado `Content-Type` de la respuesta no se establece autom√°ticamente al usar `send()` y debe establecerse manualmente. Solo se puede llamar a `send()` una vez.
- `sharedMap`: Mapa compartido entre todos los manejadores de solicitud. Cada solicitud HTTP obtendr√° una nueva instancia del mapa compartido. El mapa compartido es √∫til para compartir datos entre los manejadores de solicitud.
- `status`: C√≥digo de estado de respuesta HTTP [status code](https://developer.mozilla.org/es/docs/Web/HTTP/Status). Establece el c√≥digo de estado cuando se llama con un argumento. Siempre devuelve el c√≥digo de estado, por lo que llamar a `status()` sin argumentos se puede utilizar para devolver el c√≥digo de estado actual.
- `text`: M√©todo de conveniencia para enviar una respuesta con cuerpo de texto. La respuesta se establecer√° autom√°ticamente con el encabezado `Content-Type` en `text/plain; charset=utf-8`. Solo se puede llamar a `text()` una vez.
- `url`: Objeto de solicitud HTTP [URL](https://developer.mozilla.org/es/docs/Web/API/URL).

## Enrutamiento avanzado

Qwik City tambi√©n admite las siguientes caracter√≠sticas avanzadas de enrutamiento:

- [Par√°metros de ruta](/docs/(qwikcity)/advanced/routing/index.mdx)
- [Layouts anidados](/docs/(qwikcity)/advanced/routing/index.mdx#nested-layout)
- [Men√∫s](/docs/(qwikcity)/advanced/menu/index.mdx)

Estos temas se discuten en detalle m√°s adelante. Puedes obtener m√°s informaci√≥n sobre estas caracter√≠sticas en los enlaces proporcionados.
